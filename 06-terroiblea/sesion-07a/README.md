# sesion-07a

Martes 23 de Septiembre, 2025 

Nota del día: es difícil volver a conectarse después de una semana de receso. 

## Referentes (y otras cosas)

- **Yuk Hui** (Filósofo y teórico de la tecnología nacido en Hong Kong, conocido por su trabajo en filosofía de la tecnología y cibernética, instaló el concepto de “cosmotécnica”)
- **Líquen Lab** (espacio para el arte, la ciencia y la tecnología en Magallanes - La iniciativa sienta sus bases en un modelo de aprendizaje y educación, a partir de talleres y residencias con foco en procesos creativos y trabajo colaborativo interdisciplinario. <https://www.cultura.gob.cl/actualidad/liquen-lab-un-nuevo-espacio-para-el-arte-la-ciencia-y-la-tecnologia-en-magallanes/>)
- **Bienal de artes mediales** (encuentro de exhibición e investigación dedicado al cruce entre artes, ciencias, tecnologías y sociedad, que desde 1993 se realiza en la ciudad de Santiago de Chile. <https://cchv.cl/evento-campos-magneticos/17-bienal-de-artes-mediales-de-santiago/>)
- **cosmotécnica** (Según gemini es un concepto filosófico introducido por Yuk Hui para referirse a la relación entre un orden moral y un orden cósmico a través de la técnica. Cada cultura desarrolla su propia "cosmotécnica" basada en su comprensión del cosmos y la moralidad, como se ve en las diferencias entre las civilizaciones griega y china antiguas).
- **tecnodiversidad** (Según gemini es un concepto acuñado por Yuk Hui que propone pensar en múltiples formas de desarrollar la tecnología, más allá de un modelo universalista y moderno. Este enfoque busca reconciliar el mundo "exterior" y el mundo humano a través de la tecnología, promoviendo soluciones que respeten la ecología, la cultura y la diversidad de los conocimientos locales, y contrarrestando el colonialismo informático).
- ig: **@_todalateoriadeluniverso** (TTV -  Colectivo, Artes y Tecnologías desde Latinoamérica - Formación, editorial, residencias y festivales <https://www.instagram.com/_todalateoriadeluniverso/>)
- **NFC** - Near Field Communication (según GEMINI es una tecnología de comunicación inalámbrica de corto alcance que permite la transferencia de datos entre dos dispositivos simplemente acercándolos, como por ejemplo para realizar pagos sin contacto con el móvil o emparejar auriculares)
- **beginning NFC** (book - tom igoe, don coleman brian jepson - <https://www.amazon.com/Beginning-NFC-Communication-Arduino-PhoneGap/dp/1449372066>)
- **Nicolas Briceño Aravena** (Artista visual. Es licenciado en Artes Plásticas por la Universidad de Chile y cuenta con estudios en ingeniería informática. Ha participado en exposiciones como “Nuevas guerras / vieja propaganda” (OMA Art Gallery, 2019), “Spam” (OMA Art Gallery, 2019), “Habitar” (One Moment Gallery, 2018) y “Depresión intermedia” (Universidad Católica de Temuco, 2017). Su obra destaca por el acercamiento a otras disciplinas, como las ciencias y otras artes, especialmente la poesía. Complementa su profesión de artista trabajando como programador y consultor en informática, montajista y visualista en proyectos musicales y colaborador en Plataforma de Artes y Medios. <https://www.cultura.gob.cl/coleccionarte/nicolas-briceno-aravena/>)
- **Nuevas guerras / vieja propaganda** (obra, Nicolas Briceño - critica la producción masiva y banal de imágenes en la era digital. Usando procesos industriales, cuestiona la saturación de información y el rol ideológico de la tecnología. La pieza expone cómo temas cruciales, discursos de odio y la vida privada cohabitan con indiferencia en el caótico espacio virtual. <https://www.cultura.gob.cl/coleccionarte/nicolas-briceno-aravena/>)
- **Nic.cl** (página para ver dominios en chile - Centro de Información de Redes, nombre histórico usado en todo el mundo para definir la organización encargada de administrar los nombres de dominio en alguna categoría en Internet. <https://nic.cl/>)
- **Cwandt** - (time since launch - comenzó como una práctica de diseño de dos personas: Che-Wei Wang y Taylor Levy - Los proyectos varían desde dispositivos que alteran nuestra percepción del tiempo, un plan de estudios de electrónica para artistas, una brújula astrológica para viajeros espaciales y objetos diseñados para durar varias generaciones. <https://cwandt.com/>) (venden objetos bacanes pero caritos)
- **clock displays wrong time if** (<https://hackaday.com/2023/02/23/sneaky-clock-displays-wrong-time-if-it-catches-you-looking/>)
- Hackaday - (buena pagina para buscar proyectos <https://hackaday.com/>)
- trabajo/obra interactiva **"regalarías un buen recuerdo"** (de ig: @lapiezaoscura *"En la plaza central del GAM hemos instalado un teléfono que recoge recuerdos. ¿Qué recuerdos? Alguno que les guste, que no quieran olvidar, que puedan ofrendar a la memoria del futuro. Busquen el teléfono y vivan esta experiencia de seis minutos. Podrán donar un recuerdo a nuestro archivo, además de escuchar el que otros y otras han regalado."* <https://www.instagram.com/reel/C8ayMlUOUY_/> <https://www.instagram.com/lapiezaoscura/>)
- ig: **@lasllamadasquenuncahice** (instalación sonora de carácter performativa, que busca que la audiencia pueda decir algo inédito en un teléfono público: realizar una llamada nunca antes hecha. - autor: **Juan José Acuña** <https://www.instagram.com/lasllamadasquenuncahice/> <https://www.instagram.com/juanjoacuna/?hl=es>)
- **Nona fernández** (Patricia Paola Fernández Silanes, más conocida como Nona Fernández, es una escritora, guionista y actriz feminista chilena.)
- **Patti Smith** (Según Wikipedi, patti es cantante, compositora, artista visual y escritora estadounidense. Apodada habitualmente «la madrina del punk», ​ Smith es en una de las artistas más influyentes de la música rock)
- **Éramos unos niños** (libro de Patti Smith - cuando Patti (Smith) conoció a Robert (Mapplethorpe) y vivieron la historia de amor más intensa de todos los tiempos. <https://www.buscalibre.cl/libro-eramos-unos-ninos/9788426414052/p/3380087>)
- **Robert Mapplethorpe** (fotógrafo estadounidense, célebre por sus fotografías en blanco y negro de gran formato, especialmente de flores y desnudos masculinos. El contenido sexual de algunos de sus trabajos, calificados de pornográficos, suscitó más de una polémica durante su carrera - falleció el  9 de marzo de 1989)
- **Raul Zurita** (poeta chileno​ de ascendencia italiana conocido por sus obras innovadoras y políticamente comprometidas.​ Ha obtenido el Premio Reina Sofía de Poesía Iberoamericana 2020, Premio Nacional de Literatura 2000 y Premio Iberoamericano de Poesía Pablo Neruda 2016. )
- **Sergio Majluf** (profe udp - diseñador y Gerente de Hardware y UX en Bbrands Lab)

## Qué aprendí hoy

Formas de detectar presencia: sensores. 

Tecnologías de sensores como infrarrojos pasivos (PIR) que detectan calor corporal, ultrasónicos que usan ondas de sonido para detectar movimiento, y microondas que detectan cambios en las ondas que rebotan. Las tecnologías dual, que combinan infrarrojos y microondas, ofrecen mayor fiabilidad, mientras que los sistemas de computación en la nube como la detección de presencia de Google Home usan la ubicación de los teléfonos para identificar la presencia en casa. También existen sensores más avanzados como los de banda ultraancha (UWB) que pueden detectar movimientos muy sutiles como la respiración, o cámaras que identifican la presencia. 

### Motores

Los motores son mecanismos capaces de transformar un tipo de energía (eléctrica, de combustión, etc.) en energía mecánica. Esta transformación permite la realización de un trabajo que hace funcionar un sistema o maquinaria. 

Características: 

- Estabilidad: es la capacidad de mantenerse funcionando a altas velocidades sin consumir una cantidad excesiva de combustible o energía eléctrica.
- Potencia: es el trabajo que generan los motores en un determinado tiempo, a una velocidad específica. La potencia de un motor se expresa en kW (kilovatios), según el Sistema Internacional de Unidades; en HP (horsepower, caballos de fuerza, en inglés), en los sistemas anglosajones; o en CV (caballos de vapor), en el sistema métrico decimal.
- Rendimiento: es el resultado que se obtiene entre la potencia útil de los motores y la potencia absorbida.
- Par motor: consiste en el momento de fuerza que incide sobre el eje de los motores y que determina su giro.
- Velocidad nominal: se trata del número de revoluciones por minuto a las que giran los motores.

información sacada de: <https://www.ferrovial.com/es/stem/motores/>  

Tipos de motores: 

1. **DC (corriente continua)** - altavelocidad - es rapido y no sabe donde esta por lo tanto no entiende cual es su principio y cual es su final, giran rapido, sin mucho control, vibración. - Su principal función es convertir la energía eléctrica de una corriente continua en movimiento rotatorio continuo.
2. **Paso a Paso** - lento, preciso, tampoco sabe donde esta pero se mueve lo que se necesita. Motor del pasito, se mueve en grados (0° a 360°). - se mueve en pequeños incrementos o "pasos" angulares muy precisos. Su principal objetivo es el control exacto de la posición angular - Al enviar una serie de pulsos eléctricos, puedes hacer que gire un número exacto de grados y se mantenga fijo en esa posición.
3. **Servomotores** - de servicio, sabe donde esta y es preciso, en base a la indicación que se le da sabe donde comienza y donde termina, eje: anda al 30°, desde el 0° sabe hacia donde moverse y cuando parar a los 30°. Esta muy bien resuelto su funcionamiento en arduino - permite un control muy preciso de la posición angular, la velocidad y la aceleración. A diferencia del motor paso a paso, sabe en qué posición se encuentra en todo momento; le envías una señal (generalmente PWM) indicando el ángulo deseado, y el circuito interno compara esa posición objetivo con la posición actual del sensor y mueve el motor hasta que coincidan. 
4. **Solenoide** -  respuesta lineal, es como que apunta hacia adelante - no está diseñado para girar. Es un actuador que produce un movimiento lineal rápido y corto (empujar o tirar), es un dispositivo binario: está activado o desactivado.

+ Actuador lineal.
+ motor que utilizan las escaleras mecanicas "motor sincrono" - siempre gira a la misma velocidad, se adecua a la circunstancia.

## Qué hice hoy 

### Proyecto: Máquina que saluda

Conformación grupo de trabajo: 

nombre del grupo: por definir. (terrícolas)

- Catalina Catalán - 06-terroiblea (yo)
- Valentina Chávez - 07-valechavezalb
- Camila Delgado - 09-notcaamila
- Nicolás Miranda - 15-Nicolas-Miranda1312
- Miguel Vera - 29-MiguelVera23

La idea principal se base en darle una vuelta de tuerca a la típica máquina de dulces. Se piensa en crear una máquina que en vez de solo darte un chicle o chubbi, te tire "la suerte del día" según el color que te toque. Es como un horóscopo de dulces: el color que sacas activa una respuesta con voz y una animación en una pantalla. 

Para el diseño, se piensa en una carcasa divertida como un alien (referencia a los sirulios de 31 minutos). La carcasa la vamos a imprimir en 3D, y la idea es que la forma nos va a sirva para esconder todos los cables y las piezas. Por fuera solo se va ver la perilla para sacar el dulce (mecanico, manual - no necesita de un motor) y una pantalla circular que será su ojo gigante, el cual va a parpadear y moverse para darle más personalidad al personaje.

Entonces, cuando la persona gire la perilla y caiga el dulce, va caer directo al sensor de color y este va detectar el color que va dar paso a una respuesta. La pantalla OLED mostrará una animación en el ojo (que corresponda a lo que se está hablando) y un parlante lanzará un audio con una talla según el color. Por ejemplo, si te sale un dulce rojo, podría decirte: "¡Relaja la vena! Tómate un respiro, que parece que lo necesitái". Así, cada color tiene su propio destino/suerte.

Entrada: máquina dispensadora de dulces manual, cuando se gira la manivela te da un dulce (como chubis o m&m) y cae hacia el sensor que reconoce el color específico de este.
Salida: te da un mensaje hablado y se reproduce una animación (ojo) en relación al color que salió.

Interacción (idea):

1. Dispensador Mecánico: El usuario gira una perilla para liberar un dulce, como un chubbi o un chicle. 
2. Detección de Color: Al caer, el dulce pasa frente a un sensor de color que identifica su tonalidad (rojo, verde, azul, etc.).
3. Respuesta Inteligente: La información del color es procesada y activa dos respuestas simultáneas:

- Respuesta de Audio: Un parlante reproduce un mensaje pregrabado. El saludo base es "Hola Terrícola", seguido de una frase asociada específicamente al color detectado.
- Respuesta Visual: Una pantalla circular, que representa el único ojo del alien, muestra una animación. El ojo puede parpadear, moverse o cambiar de expresión en base al color que se detecta.

Lista de materiales a utilizar en el proyecto: 

- Sensor reconocimiento de color Tcs230 - Tcs3200.
- Módulo reproductor Mp3 deplayer mini.
- Mini parlante altavoz de 3W.
- Pantalla TFT Circular 1.24 Pulgadas RGB 240x240.

Cotización sensor color:

- Afel: $5.000 (<https://afel.cl/products/sensor-reconocimiento-de-color-tcs230-tcs3200>)
- Raspberry: $4.890 (<https://raspberrypi.cl/producto/sensor-reconocimiento-de-color-tcs230-tcs3200/>)
- Mci electronics: $4.890 (<https://mcielectronics.cl/shop/product/sensor-reconocimiento-de-color-tcs230-tcs3200/>)

Cotización Módulo Mp3:

- Afel: $2.990 (<https://afel.cl/products/modulo-reproductor-mp3-dfplayer-mini>)
- Altronics: $4.076 (<https://altronics.cl/reproductor-mp3-dfplayer-mini>)
- Mercado libre: $5.190 (<https://articulo.mercadolibre.cl/MLC-1015454915#origin=share&sid=share&action=copy>)

Cotización altavoz:

- Afel: $3.000 (<https://afel.cl/products/mini-parlante-altavoz-de-3w>)
- Mercado libre: $4.750 (<https://www.mercadolibre.cl/up/MLCU357297374?pdp_filters=item_id:MLC2381966008#origin=share&sid=share&wid=MLC2381966008&action=copy>)

Ideas generales extra: 

- podría ser que tenga una respuesta de color iluminado por un led, que se replique el color del chubi para confirmar que lo reconocio bien y despues te da el mensaje. 
- pensar en uso de botones para cosas como reset.
- el alien te saluda animosamente con un audio que te dice: "Hola Terrícola" antes de dar el mensaje especifico en relación al color.
- se podría usar MyM para tener un mínimo de 6 opciones distintas de colores.
- se podría asignar 2 audios distintos por color y que así las respuestas sean más al "azar".
- hacerle una capa de genero negro al alien.
- modo stand by puede ser el ojo durmiendo. 

## Encargo 

Leer las bitacoras de colegas, encontrar similitudes, diferencias, preguntas y aciertos de sus máquinas saludadoras propuestas. Citar correctamente las fuentes y buscar 2 referentes asociados a tu proyecto de cada una de estas 4 categorías: 1. lenguaje natural (personas), 2. código, 3. materialidad, 4. documentación. escribir un párrafo por cada uno de los referentes encontrados, citando las fuentes, y explicando por qué lo elegiste, qué te aporta, qué te inspira, o incluso si lo incluyes como antiejemplo.

### Análisis bitacoras 

#### Similitudes (Puntos en común de todos los proyectos):

- **Interacción por Sensores:** Todos los proyectos se basan en la idea de usar sensores (proximidad, color, calor, botones) para detectar al usuario e iniciar una interacción.
- **Respuesta Inmediata:** La respuesta de la máquina es siempre inmediata, usando una combinación de sonido (voz, música), elementos visuales (pantallas, ojos móviles, luces) o movimiento.
- **Estado de Reposo:** La mayoría de las máquinas tiene un modo de espera o "dormido" que se activa solo cuando alguien se acerca o interactúa.
- **Búsqueda de una Experiencia:** El objetivo general no es solo un saludo mecánico, sino crear una experiencia lúdica, memorable y amistosa, a menudo con toques de humor.
- **Uso de Audio:** Prácticamente todos los proyectos utilizan un altavoz para emitir un saludo hablado o sonidos.

#### Diferencias (Los aspectos que varían entre proyectos)

El Gatillo de la Interacción: El "cómo" se activa la máquina es muy distinto en cada caso:

- Unos por la proximidad y distancia de la persona.
- Otro por el color de un dulce dispensado.
- Otro por la detección de calor corporal.
- Otros por una acción directa (girar una perilla, presionar algo).
  
Personalidad y Narrativa: Cada máquina tiene un "tono" diferente:

- Algunas son un personaje definido (un alien, un monstruo misterioso).
- Otras son más irónicas y graciosas (una oreja que habla).
- Otras son más funcionales o minimalistas, sin un personaje claro.
  
Complejidad de la Interacción: El nivel de la conversación varía:

- Algunas dan un saludo simple y directo.
- Otras tienen una interacción por etapas (lejos, cerca, íntimo).
- Otras ofrecen mensajes personalizados y variables (según el color del dulce).

Componentes Físicos: Aunque todos usan Arduino y sensores, los elementos principales cambian: 

- un dispensador de dulces, ojos que siguen, una oreja-parlante, una habitación con sensores, etc.

#### Preguntas que surgen (Dudas y desafíos comunes)

- **Precisión Técnica:** ¿Cómo calibrar bien los sensores (de distancia, de color) para que no fallen, no den falsos positivos o funcionen correctamente?
- **Mantener el Interés:** ¿Cómo evitar que la interacción se vuelva aburrida y repetitiva? ¿Qué estrategias se pueden usar para que la gente quiera volver a interactuar?
- **Interacción Múltiple:** ¿Qué pasa si varias personas intentan usar la máquina al mismo tiempo? ¿Cómo respondería?
- **Casos Límite:** Se plantean dudas sobre situaciones específicas, como ¿qué pasa si la máquina de dulces se queda sin chicles? (mi compañero de grupo lo plantea) ¿O si el sensor no detecta nada?

#### Aciertos Identificados 

- **Creatividad Conceptual:** Se valora mucho la originalidad de las ideas, como la ironía de una oreja que habla o el misterio de un secreto susurrado.
- **Creación de Personajes Atractivos:** El uso de elementos visuales fuertes, como un ojo animado en una pantalla o unos ojos que te siguen por la sala, es muy efectivo para atraer la atención y dar vida al proyecto.
- **Sorpresa y Variedad:** Es un gran acierto que la respuesta no sea siempre la misma. Usar sonidos aleatorios para cambiar el mensaje hace la experiencia mucho más interesante.
- **Uso del Humor:** Integrar humor y una personalidad clara en la máquina (ya sea en los mensajes o en el concepto) hace que la interacción sea mucho más memorable. (y me gusta que casi todos los grupos se hayan ido por esa idea, de que sea algo divertido)
- **Interacción Cotidiana Reimaginada:** Tomar una acción común y convertirla en una experiencia sorprendente es una de las ideas que más me gustan y creo que casi todos los grupos logran un poquito de esto.

### Referentes 

#### Lenguaje natural

#### Código

Los referentes de código que consegui son en relación a la calibración inicial que tiene que tener el sensor de color para poder ser usado y que detecte los colores en base a "códigos" RGB. 

##### MCI EDUCATION: 

- <https://cursos.mcielectronics.cl/2022/12/26/interfaz-del-sensor-de-color-tcs230-tcs3200-con-arduino/>

En el link sale la explicación de cada parte del código (desgloce) y que tipo de resultados deberían tener cada parte. 

Código parte 01: 

El primer código cumple la función de calibrar el sensor de color TCS230, permitiendo obtener los valores sin procesar que el sensor entrega para cada componente de color (rojo, verde y azul) al medir distintos objetos. A través de estas lecturas, se identifican los valores mínimos y máximos correspondientes a referencias blancas y negras, lo que permite establecer un punto de partida preciso para interpretar correctamente los colores en el proyecto principal.

```cpp
// Define color sensor pins
#define S0 4
#define S1 5
#define S2 6
#define S3 7
#define sensorOut 8

// Variables for Color Pulse Width Measurements
int redPW = 0;
int greenPW = 0;
int bluePW = 0;

void setup() {
	// Set S0 - S3 as outputs
	pinMode(S0, OUTPUT);
	pinMode(S1, OUTPUT);
	pinMode(S2, OUTPUT);
	pinMode(S3, OUTPUT);

	// Set Pulse Width scaling to 20%
	digitalWrite(S0,HIGH);
	digitalWrite(S1,LOW);

	// Set Sensor output as input
	pinMode(sensorOut, INPUT);

	// Setup Serial Monitor
	Serial.begin(9600);
}

void loop() {
	// Read Red Pulse Width
	redPW = getRedPW();
	// Delay to stabilize sensor
	delay(200);

	// Read Green Pulse Width
	greenPW = getGreenPW();
	// Delay to stabilize sensor
	delay(200);

	// Read Blue Pulse Width
	bluePW = getBluePW();
	// Delay to stabilize sensor
	delay(200);

	// Print output to Serial Monitor
	Serial.print("Red PW = ");
	Serial.print(redPW);
	Serial.print(" - Green PW = ");
	Serial.print(greenPW);
	Serial.print(" - Blue PW = ");
	Serial.println(bluePW);
}


// Function to read Red Pulse Widths
int getRedPW() {
	// Set sensor to read Red only
	digitalWrite(S2,LOW);
	digitalWrite(S3,LOW);
	// Define integer to represent Pulse Width
	int PW;
	// Read the output Pulse Width
	PW = pulseIn(sensorOut, LOW);
	// Return the value
	return PW;
}

// Function to read Green Pulse Widths
int getGreenPW() {
	// Set sensor to read Green only
	digitalWrite(S2,HIGH);
	digitalWrite(S3,HIGH);
	// Define integer to represent Pulse Width
	int PW;
	// Read the output Pulse Width
	PW = pulseIn(sensorOut, LOW);
	// Return the value
	return PW;
}

// Function to read Blue Pulse Widths
int getBluePW() {
	// Set sensor to read Blue only
	digitalWrite(S2,LOW);
	digitalWrite(S3,HIGH);
	// Define integer to represent Pulse Width
	int PW;
	// Read the output Pulse Width
	PW = pulseIn(sensorOut, LOW);
	// Return the value
	return PW;
}
```

Código parte 02: 

El segundo código utiliza los datos obtenidos en la calibración para convertir las lecturas del sensor en valores RGB reales, comprendidos entre 0 y 255. Este programa traduce las señales medidas (ancho de pulso) en colores digitales legibles, permitiendo que el sensor identifique con mayor precisión el color de los objetos que detecta.

```cpp
// Define color sensor pins
#define S0 4
#define S1 5
#define S2 6
#define S3 7
#define sensorOut 8

// Calibration Values
// *Get these from Calibration Sketch
int redMin = 0; // Red minimum value
int redMax = 0; // Red maximum value
int greenMin = 0; // Green minimum value
int greenMax = 0; // Green maximum value
int blueMin = 0; // Blue minimum value
int blueMax = 0; // Blue maximum value

// Variables for Color Pulse Width Measurements
int redPW = 0;
int greenPW = 0;
int bluePW = 0;

// Variables for final Color values
int redValue;
int greenValue;
int blueValue;

void setup() {
	// Set S0 - S3 as outputs
	pinMode(S0, OUTPUT);
	pinMode(S1, OUTPUT);
	pinMode(S2, OUTPUT);
	pinMode(S3, OUTPUT);

	// Set Sensor output as input
	pinMode(sensorOut, INPUT);

	// Set Frequency scaling to 20%
	digitalWrite(S0,HIGH);
	digitalWrite(S1,LOW);

	// Setup Serial Monitor
	Serial.begin(9600);
}

void loop() {
	// Read Red value
	redPW = getRedPW();
	// Map to value from 0-255
	redValue = map(redPW, redMin,redMax,255,0);
	// Delay to stabilize sensor
	delay(200);

	// Read Green value
	greenPW = getGreenPW();
	// Map to value from 0-255
	greenValue = map(greenPW, greenMin,greenMax,255,0);
	// Delay to stabilize sensor
	delay(200);

	// Read Blue value
	bluePW = getBluePW();
	// Map to value from 0-255
	blueValue = map(bluePW, blueMin,blueMax,255,0);
	// Delay to stabilize sensor
	delay(200);

	// Print output to Serial Monitor
	Serial.print("Red = ");
	Serial.print(redValue);
	Serial.print(" - Green = ");
	Serial.print(greenValue);
	Serial.print(" - Blue = ");
	Serial.println(blueValue);
}


// Function to read Red Pulse Widths
int getRedPW() {
	// Set sensor to read Red only
	digitalWrite(S2,LOW);
	digitalWrite(S3,LOW);
	// Define integer to represent Pulse Width
	int PW;
	// Read the output Pulse Width
	PW = pulseIn(sensorOut, LOW);
	// Return the value
	return PW;
}

// Function to read Green Pulse Widths
int getGreenPW() {
	// Set sensor to read Green only
	digitalWrite(S2,HIGH);
	digitalWrite(S3,HIGH);
	// Define integer to represent Pulse Width
	int PW;
	// Read the output Pulse Width
	PW = pulseIn(sensorOut, LOW);
	// Return the value
	return PW;
}

// Function to read Blue Pulse Widths
int getBluePW() {
	// Set sensor to read Blue only
	digitalWrite(S2,LOW);
	digitalWrite(S3,HIGH);
	// Define integer to represent Pulse Width
	int PW;
	// Read the output Pulse Width
	PW = pulseIn(sensorOut, LOW);
	// Return the value
	return PW;
}
```

- Escogí esta referencia porque representa la base necesaria para todo el desarrollo posterior: antes de poder decir “quiero sensar los colores de los dulces”, es imprescindible calibrar el sensor y darle los datos que le permitan “reconocer” los colores con precisión. Este proceso es fundamental, ya que asegura que las mediciones sean confiables y coherentes con la realidad. Además, permite comprender cómo el sensor interpreta el color según las condiciones del entorno (como la luz o la distancia) y aporta rigor técnico al proyecto.

##### Bitwise Ar

- <https://www.youtube.com/watch?v=GjEEzKfXfik>

```cpp
#define S0 4		// S0 a pin 4
#define S1 5		// S1 a pin 5
#define S2 6		// S2 a pin 6
#define S3 7		// S3 a pin 7
#define salidaTCS 8	// salidaTCS a pin 8


void setup() {
  pinMode(S0, OUTPUT);		// pin 4 como salida
  pinMode(S1, OUTPUT);		// pin 5 como salida
  pinMode(S2, OUTPUT);		// pin 6 como salida
  pinMode(S3, OUTPUT);		// pin 7 como salida
  pinMode(salidaTCS, INPUT);	// pin 8 como salida
  
  digitalWrite(S0,HIGH);	// establece frecuencia de salida
  digitalWrite(S1,LOW);		// del modulo al 20 por ciento
  
  Serial.begin(9600);		// inicializa monitor serie a 9600 bps
}

void loop() {
  digitalWrite(S2,LOW);			// establece fotodiodos
  digitalWrite(S3,LOW);			// con filtro rojo
  int rojo = pulseIn(salidaTCS, LOW);	// obtiene duracion de pulso de salida del sensor
  delay(200);				// demora de 200 mseg
  
  digitalWrite(S2,HIGH);		// establece fotodiodos
  digitalWrite(S3,HIGH);		// con filtro verde
  int verde = pulseIn(salidaTCS, LOW);	// obtiene duracion de pulso de salida del sensor
  delay(200);				// demora de 200 mseg
  
  digitalWrite(S2,LOW);			// establece fotodiodos
  digitalWrite(S3,HIGH);		// con filtro azul
  int azul = pulseIn(salidaTCS, LOW);	// obtiene duracion de pulso de salida del sensor
  delay(200);				// demora de 200 mseg
  
  Serial.print("R:");			// muestra texto
  Serial.print(rojo);			// muestra valor de variable rojo

  Serial.print("\t");			// espacio de tabulacion

  Serial.print("V:");			// muestra texto
  Serial.print(verde);			// muestra valor de variable verde

  Serial.print("\t");			// espacio de tabulacion

  Serial.print("A:");			// muestra texto
  Serial.println(azul);			// muestra valor de variable azul
  					// y salto de linea
  
  if ( rojo < 150 && verde > 300 && azul > 60){		// si valores dentro del rango
    Serial.println("ROJO");				// muestra texto
  } 
    else if ( verde < 300 && rojo > 300 && azul > 80){	// si valores dentro del rango
    Serial.println("VERDE");				// muestra texto
  }
    else if ( azul < 50 && rojo > 200 && verde > 100){	// si valores dentrol del rango
    Serial.println("AZUL");				// muestra texto
  }
}
```

Este ejemplo es importante porque muestra de forma clara y visual cómo traducir los valores del sensor en una interpretación inmediata del color. Es una forma práctica de entender la lógica del TCS230 antes de pasar a proyectos más complejos o calibraciones precisas. Además, permite experimentar y ajustar los umbrales según el entorno o el tipo de color que se quiera reconocer (por ejemplo, los colores de los dulces).

Ademas, esta parte del código:

```cpp
if (rojo < 150 && verde > 300 && azul > 60) {
  Serial.println("ROJO");
} 
else if (verde < 300 && rojo > 300 && azul > 80) {
  Serial.println("VERDE");
}
else if (azul < 50 && rojo > 200 && verde > 100) {
  Serial.println("AZUL");
}
```

Demuestra cómo traducir las mediciones del sensor en una lógica de decisión, enseñando que identificar un color no depende solo de un valor absoluto, sino de la relación entre los tres canales RGB. Ajustar esos parámetros permite afinar la sensibilidad del sensor y mejorar su precisión, logrando que el dispositivo realmente “reconozca” los colores de forma confiable dentro del contexto del proyecto.

El TCS230 no “ve” colores como tal, sino que mide el ancho de los pulsos que corresponden a la intensidad de luz reflejada en cada componente (rojo, verde y azul).
Cuanto menor es el valor, más fuerte es la presencia de ese color en la superficie que se está midiendo.

- Por ejemplo:

En azul `< 50 && rojo > 200 && verde > 100`, el código interpreta que hay una señal azul fuerte (valor bajo) y señales roja y verde más débiles (valores altos), por lo tanto el color detectado es azul. De forma similar, para verde `< 300 && rojo > 300 && azul > 80`, el color verde domina porque su valor es bajo en comparación con los otros dos.

- A considerar: Estos umbrales numéricos se ajustan manualmente según el entorno (iluminación, distancia del sensor, tipo de superficie). Es decir, si el sensor está más cerca o la luz cambia, los valores que definen si algo es “azul” o “verde” pueden variar y deben **recalibrarse**.

#### Materialidad

En conversaciones con el grupo acordamos que lo mejor sería utilizar impresión 3d para hacer la carcasa que sostenga y contenga todo lo que se planea utilizar, asi que me enfoque en buscar referentes de impresión 3D o que su materialidad fuera parecida. 

##### Otto DIY (Robot de código abierto)

- <https://www.ottodiy.com/>

Otto es un robot bípedo impreso en 3D que aloja componentes de Arduino en su interior. Lo seleccioné como referente de materialidad porque es un buen ejemplo de diseño para la fabricación digital. Su cuerpo está pensado en partes que se ensamblan fácilmente, ocultan todos los cables y componentes, y a la vez crean un personaje simpático/divertido. Creo que nos puede ayudar a diseñar la carcasa del alien de la misma forma: no como una simple caja, sino como un conjunto de piezas modulares que me permitan acceder fácilmente al Arduino y al sensor para hacer mantención o ver si es que algo se desconecta, pero que una vez ensambladas, formen un personaje sólido y sin tornillos a la vista. 

##### Adafruit Color Sensors 

- <https://learn.adafruit.com/adafruit-color-sensors/overview>

Mi elección de antiejemplo de materialidad sería utilizar acrílico transparente delgado o en general alguna materialidad que sea transparente o de color claros. ya que en este artículo técnico de Adafruit, explican cómo la luz ambiental y la transparencia del material afectan directamente la precisión de los sensores de color, lo que afectaría a todo el proyecto (se especifica que por ejemplo el material al deja pasar demasiada luz ambiental, altera las lecturas del sensor de color y dificulta la calibración. Además, no bloquea reflejos ni filtra correctamente la luz, generando errores en la detección de los colores reales del objeto).

En la sección “Working with Light”, Adafruit menciona que los sensores de color requieren controlar la iluminación y evitar materiales transparentes o reflectantes cerca del área de medición, ya que estos distorsionan las lecturas. La materialidad debe proteger, estabilizar y acompañar el funcionamiento del sensor, evitando interferencias ópticas. Por eso, materiales opacos o con acabado mate (como PLA negro, MDF pintado o ABS) serían mucho más adecuados.

#### Documentación 

##### Mark Rober (Canal de YouTube)

- buscar cualquier video de su canal (ej: <https://www.youtube.com/watch?v=Sqr-PdVYhY4> <https://www.youtube.com/watch?v=Twn_4AW0M6U>)

Escogí a este referente de documentación porque sus videos no son solo tutoriales: son historias. Explican el problema, el proceso de diseño (incluyendo los fracasos), la construcción y el resultado final de una manera entretenida. Creo que nos puede ayudar a documentar el proceso del trabajo no solo con fotos del resultado, sino con videos cortos que muestren cómo por ejemplo se modelo el alien, los problemas que se tuvieron con el sensor de color, entre otros. Es un referente para contar la "historia" del proyecto.

##### How To Mechatronics (canal de Youtube)

- buscar cualquier video de su canal (ej: <https://www.youtube.com/watch?v=Ho4AniHtgxM>) 

Escogí estre otro referente porque no es un show de entretenimiento (como Mark Rober), sino una presentación clara y metódica de un prototipo funcional. Lo elegí porque su estructura es un modelo a seguir para una presentación académica: comienza mostrando el producto final en acción, luego desglosa de manera ordenada la construcción mecánica (con piezas impresas en 3D), el circuito electrónico y finalmente, la lógica del código. Me aporta una guía visual de cómo contar la historia de una construcción, demostrando que una buena documentación no necesita una narrativa compleja, sino una explicación lógica y bien segmentada que permita a cualquiera entender cómo se hizo y cómo funciona. 
